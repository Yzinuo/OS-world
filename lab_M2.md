# Makefile
    $@ : 目标
    $^ : 所有依赖项
    $< : 第一个依赖项

    .PHONY : Clean :防止目录下正好有一个文件名叫clean。导致clean命令执行不了。

# 共享库

当linux代码中没有main函数，它不会编译成可运行的二进制文件，而是会生成共享库（动态链接库） libco.so

编译：
```
$(NAME)-64.so: $(DEPS) # 64bit shared library
    gcc -fPIC -shared -m64 $(CFLAGS) $(SRCS) -o $@ $(LDFLAGS)
```

其中 -fPIC -fshared 就代表编译成位置无关代码的共享库。除此之外，共享库和普通的二进制文件没有特别的区别

# 使用动态链接库

编译：
```
gcc -I.. -L.. -m64 main.c -o libco-test-64 -lco-64
gcc -I.. -L.. -m32 main.c -o libco-test-32 -lco-32
```

-   -I 选项代表 include path，使我们可以 #include <co.h>。你可以使用 gcc --verbose 编译看到编译器使用的 include paths。
-   -L 选项代表增加 link search path。
-   -l 选项代表链接某个库，链接时会自动加上 lib 的前缀，即 -lco-64 会依次在库函数的搜索路径中查找 libco-64.so 和 libco-64.a，直到找到为止。如果你将 libco-64.so 删除后用 strace 工具查看 gcc 运行时使用的系统调用，就能清晰地看到库函数解析的流程；
  
```
LD_LIBRARY_PATH=.. ./libco-test-64

```
如果不设置 LD_LIBRARY_PATH 环境变量，你将会遇到 “error while loading shared libraries: libco-xx.so: cannot open shared object file: No such file or directory” 的错误。

LD_LIBRARY_PATH 是一个环境变量，用于在程序运行时指定动态链接库（共享库）的搜索路径。当你运行一个程序，而它需要加载动态链接库时，系统会首先在 LD_LIBRARY_PATH 指定的目录中查找这些库。

如果不设置 LD_LIBRARY_PATH，系统将只在默认的库路径（如 /lib 和 /usr/lib）中搜索所需的共享库。如果你的库文件不在这些默认路径中，比如在一个本地目录或者其他非标准位置，你就需要设置 LD_LIBRARY_PATH 来包含这些目录，否则程序在尝试加载库时会报错，提示无法找到共享对象文件


# 汇编

## 基础知识
在计算机科学中，“位”（bit）是最基本的数据单位，代表一个二进制数字，即0或1。每8个位组成一个字节（Byte），是存储和处理信息的基本单位。

“16位”和“32位”通常指的是计算机处理器的字长，即CPU一次能处理的数据的位数。16位处理器一次可以处理16位的数据，而32位处理器可以处理32位的数据。这影响了计算机的性能和能处理的内存量。例如，32位计算机的字长是32位，通常意味着它可以使用的最大内存是4GB。2^32

x86架构是一种广泛使用的计算机处理器架构，最初由Intel开发。它以Intel的8086处理器命名，该处理器是16位的。随后，这个架构发展为32位（IA-32）和64位（x86-64或AMD64）。x86架构以其复杂指令集计算（CISC）而闻名，提供了丰富的指令集来执行各种操作。这种架构主要用于个人电脑和服务器，并且支持Windows、macOS和Linux等多种操作系统。

## 寄存器
- %rbp（基指针寄存器）：在函数调用中，%rbp通常用于存储栈帧的基地址，它是访问函数参数和局部变量的参考点。
- %rbx（基址寄存器）：%rbx是一个通用寄存器，通常用于在程序中保存一个值，以便后续使用。在协程或函数中，它可能被用来保存一个状态或者一个重要的中间值。
- %rsp（栈指针寄存器）：%rsp指向当前的栈顶。当你执行sub $0x8, %rsp时，实际上是在栈上为局部变量或临时数据分配空间。
- %rdi（目的索引寄存器）：在函数调用的参数传递中，%rdi通常用于存储第一个参数的值。
- %rsi（源索引寄存器）：%rsi通常用于存储第二个参数的值。
- %rax（累加器寄存器）：%rax是最常用的寄存器之一，用于存储函数的返回值或者进行算术运算的结果。
- %rbx（基址寄存器）：在汇编语言中，%rbx 是一个通用寄存器，通常用于数据存储。它是一个被调用者保存（callee-saved）寄存器，意味着如果一个函数调用了另一个函数（子函数），那么这个子函数在使用 %rbx 之前需要先保存其原始值，并在使用后恢复，以保证调用者（父函数）的 %rbx 值不会被改变。在您的代码中，如果 %rbx 被用作循环计数器，它可能被用来存储循环的迭代次数或跟踪某个过程的执行次数，如 printf 函数调用的次数。这是 %rbx 的典型用途之一，因为它的值在函数调用之间是保持不变的。
  
- %eax（累加器寄存器的低32位）：在调用可变参数的函数（如printf）之前，%eax通常被清零，以表示没有使用浮点数寄存器传递参数。


在x86-64架构的调用约定中，当调用一个可变参数的函数（比如printf），整数和浮点数参数通常是通过不同的寄存器传递的。整数参数通过通用寄存器传递，而浮点数参数则通过XMM寄存器传递。这种区分是为了优化性能，因为整数和浮点数在处理器内部是以不同的方式处理的。

对于可变参数的函数，调用者（即调用函数的代码）不知道被调用的函数将接收多少个参数，以及这些参数的具体类型。因此，x86-64调用约定规定，在调用可变参数的函数之前，必须在%al（%rax的低8位）中设置传递给函数的浮点参数的数量。这样，被调用的函数就知道应该从哪些XMM寄存器中获取浮点数参数。

然而，当函数不接收任何浮点参数时，%al应该被清零，这样被调用的函数就知道不需要从XMM寄存器中获取参数。在您的代码中，xor %eax, %eax这条指令就是用来清零%eax的，由于%al是%eax的一部分，这也间接清零了%al，告诉printf函数没有浮点数参数传递。
