# 计数器
我们实现一个计数器的并发可以：
![alt text](image-21.png)
但实际上，这个实现性能比较差，和单线程程序比还慢了近五十倍。这主要是多个线程的竞争导致。
## 懒惰计数器
**懒惰计数器通过多个局部计数器和一个全局计数器来实现一个逻辑计数器**，其中每个CPU 核心有一个局部计数器。具体来说，在 4 个 CPU 的机器上，有 4 个局部计数器和 1 个全局计数器。除了这些计数器，还有锁：每个局部计数器有一个锁，全局计数器有一个。

每次线程要要增加计数，只需要在自己的线程上添加就行了，每次局部计数器到达一个阈值就会去争抢全局计数器，增加到全局计数器上。这样大部分时间线程不会竞争线程，性能很高，但是相应的，我们去读全局计数器就很可能不准。  
阈值越高，性能越好，准确性就越差。

懒惰计数器就是在准确性和性能之间折中。

---

# 并发列表
异常处理流发生概率很小，因此错误不常被发现。linux的内核补丁中有百分之四十是在优化异常处理流。 所以启示我们最好不要在异常处理流中进行复杂操作，如解锁等（可能你看着逻辑没问题但是就会出奇怪的问题）。
![alt text](image-22.png)
修改后：不在函数一开始就上锁，而是要锁围绕真正的临界区资源。
![alt text](image-23.png)

**在并发编程中最好只保持单一的返回路径，降低了忘记释放锁的可能性。**

并发列表的实现；
![alt text](image-24.png)


# 提示：当心锁和控制流
对并发代码和其他代码都有用，即注意控制流的变化导致函数返回和退出，或其他错误情况导致函数停止执行。因为很多函数开始就会获得锁，分配内存，或者进行其他一些改变状态的操作，如果错误发生，代码需要在返回前恢复各种状态，这容易出错。因此，最好组织好代码，减少这种模式。

# 并发队列
并发队列中，我们应该用两把锁分别控制列头和列尾，这样能有效较少锁的争抢和释放浪费的时间。


# 实现的注意事项
我们应该从易入难。实现并发的数据结构时，我们应该先用一把大锁实现，这样很可能是对的。。在此基础上在进行性能优化。

“一切不成熟的优化是坏事的根源”，linux也是一开始都用一把大锁（BKL）的，后来多处理器才过度到多个锁。

增加并发不是总能提示性能。


**调用signal 和 wait，broadcost 时都需要锁。**

# 生产者和消费者实现过程的错误:

## 为什么生产者和消费者 问题中 要用while 而不是if
虽然逻辑上if在单生产者和单消费者中也能实现功能，但是当一个生产者多个消费者时：
C1检查没有数据过后进入睡眠，此时P1生产数据放入buffer唤醒C1，但是C2先抢到了锁执行消费了buffer中的数据，此时C1被唤醒消费但是已经没有数据了。 导致错误。

**发信号给线程只是唤醒它们，暗示状态发生了变化（在这个例子中，就是值已被放入缓冲区），但并不会保证在它运行之前状态一直是期望的情况。**

Mesa语义：条件变量总是用while循环，这样做总是安全的。

![alt text](image-25.png)

## 信号必须要有指向性。
消费者不应该唤醒消费者，而是只唤醒生产者，反之亦然。

---

# 信号量
sem_init()的第二个参数，在我们看到的所有例子中都设置为 0，表示信号量是在同一进程的多个线程共享的。

可能多个调用线程都调用 sem_wait()，因此都在队列中等待被唤醒
sem_post()并没有等待某些条件满足。它直接增加信号量的值，如果有等待线程，唤醒其中一个。

**信号量中的post wait操作都是原子的。**

## 当信号量初始值为1时，信号量可以做锁使用，即二值信号量
重点：信号量操作都是原子的，不可被中断的，不会并行的，因此可以做锁用。

同一时刻只有一个线程能通过P操作或进行V操作

## 信号量实现生产者消费者
![alt text](image-26.png)

**在临界区一定要上锁，锁要紧密的围绕临界区。**



