# 可执行文件
**可执行文件**: execve加载完后,地址空间里应该有的东西,是一个描述了状态机初始状态的数据结构.

**PE（Portable Executable）**格式
PE格式是Windows操作系统中使用的可执行文件格式。它的结构主要包括以下几个部分：

**文件头（File Header）**：

**文件头**包含了关于文件的基本信息，比如文件的类型（是可执行文件、动态链接库还是其他类型）、文件的大小、程序的入口点（程序从哪里开始执行）等。

**段表（Section Table）：**

段表是一个表格，列出了文件中所有的段（Section）。每个段是一个逻辑上的块，包含了代码、数据或其他类型的信息。
例如，有一个段可能包含了程序的代码（机器指令），另一个段可能包含了程序的数据（全局变量和静态变量）。

**符号表（Symbol Table）：**

符号表包含了程序中定义和引用的符号（如函数名、变量名等）。
符号表在链接和调试过程中非常重要，因为它可以帮助链接器找到正确的函数和变量，也可以帮助调试器显示有意义的符号名。

**重定位表（Relocation Table）：**

重定位表的概念
重定位表（Relocation Table）是一个包含需要重定位的地址的列表。当一个程序被编译和链接成可执行文件时，编译器和链接器并不知道这个程序将来会被加载到内存中的哪个位置。因此，它们会在可执行文件中留下一些“占位符”，这些占位符在程序被加载到内存时需要被调整（重定位）。

**例子**
假设我们有一个简单的C程序：

```c
#include <stdio.h>

int global_var = 42;

void print_global_var() {
    printf("Global variable: %d\n", global_var);
}

int main() {
    print_global_var();
    return 0;
}
```
当我们编译这个程序时，编译器会生成机器代码和数据。假设在生成的机器代码中，有一条指令是用来访问全局变量 global_var 的。由于编译器不知道 global_var 在内存中的确切地址，它会生成一个“占位符”地址。

重定位表的作用
重定位表的作用就是记录这些“占位符”地址，并在程序被加载到内存时，根据实际的加载地址对这些地址进行调整。

假设在生成的可执行文件中，有一条指令是用来访问 global_var 的，这条指令的地址部分是一个“占位符”地址，比如 0x1000。重定位表会记录这个地址 0x1000 需要被重定位。

当操作系统加载这个程序到内存时，假设 global_var 的实际地址是 0x8000。操作系统会查找重定位表，找到地址 0x1000，并将其调整为 0x8000。

重定位表的结构
重定位表通常包含以下信息：

需要重定位的地址：这是在可执行文件中的一个偏移量，指向需要被调整的地址。

重定位类型：这指定了如何调整这个地址。不同的重定位类型有不同的调整方式。
符号索引：这指向符号表中的一个条目，表示这个地址需要被调整到哪个符号的实际地址。在可执行文件中，确实会有很多占位符。这些占位符主要出现在以下几个地方：

全局变量和静态变量的地址：在程序中访问全局变量和静态变量时，编译器会生成占位符来表示这些变量的地址。

函数调用的地址：在调用函数时，编译器会生成占位符来表示函数的入口地址。

动态链接库中的符号地址：如果程序依赖于动态链接库（如Windows的DLL或Linux的共享对象），在编译时这些符号的地址也是未知的，因此也需要使用占位符。


**ELF（Executable and Linkable Format）格式**
ELF格式是Unix/Linux操作系统中使用的可执行文件格式。它的结构和PE格式类似，也包括文件头、段表、符号表和重定位表等部分，但具体的细节可能有所不同。

文件头（File Header）：

和PE格式一样，ELF文件头包含了文件的基本信息，如文件类型、文件大小、程序入口点等。

段表（Section Table）：

ELF文件中的段表也列出了文件中所有的段。每个段包含了代码、数据或其他类型的信息。

符号表（Symbol Table）：

ELF文件中的符号表同样包含了程序中定义和引用的符号。

重定位表（Relocation Table）：

ELF文件中的重定位表也包含了需要重定位的地址的列表

---

# Friendly Leawrning Executable

ELF是复杂的,它为了性能而抛弃了许多易读性. 我们读readelf 不异于读天书.所以老师创建了fle,帮我们理解elf的核心组成部分.

链接和加载中的核心概念:**代码,符号,重定位**.所以抓住这三个要点,我们可以自己实现一个人类易读的,可执行文件结构 'FLE'.

首先老师把文件编译成ELF格式,然后把ELF重要的三点提取出来自定义成FLE格式,其次老师展示了怎么链接FLE格式且运行FLE格式

**obj目标二进制文件中,常常包含.txt代码段和.data数据段.**  从代码段我们可以清晰看到它包含_text书签(书签标记代码的某段),foo全局书签,代码段,重定位. 
![Alt text](image-46.png)
这就是可执行文件的基本架构

### 编译过程:
**预处理（Preprocessing）：**
编译器首先对 .c 源文件进行预处理。预处理器会处理源文件中的预处理指令（如 #include、#define 等），并生成一个预处理后的文件，通常以 .i 或 .ii 为扩展名。

**编译（Compilation）：**

接下来，编译器将预处理后的文件编译成汇编语言文件。这个阶段会将 C 代码翻译成汇编代码，生成的文件通常以 .s 为扩展名。

**汇编（Assembly）：**

汇编器将汇编语言文件转换成机器代码，生成目标文件（Object File）。目标文件包含了机器指令、数据和重定位信息等，通常以 .o 或 .obj 为扩展名。

**链接（Linking）：**

最后，链接器将一个或多个目标文件与库文件（如标准库、第三方库等）链接在一起，生成可执行文件或共享库。链接器会解析目标文件中的符号引用，并生成最终的可执行文件，通常以 .exe（Windows）或elf（Unix/Linux）。在此阶段中,为程序代码分配虚拟内存地址.此时确定了entry point等


## 编译器链接
链接后,每个文件都有自己的.txt .data, 链接后类似合并同类项,把.txt都和在一起,把.data都合在一起. 在这种情况下,各个段的各个符号的内存位置(已经分配虚拟内存)就已经确定了,就可以完成重定向. 至此,可执行文件的三要素就齐全了:符号,代码,重定向.

当可执行文件被加载到内存中时，操作系统会根据ELF文件中的信息（如程序头表）将各个段加载到相应的虚拟地址。动态链接器会在程序运行前处理动态链接库的加载和符号解析。

## Shebang
Unix世界中为了程序不太冗长,允许在编译文件开头中加上:

```shell
#!+编译器名称
```

# ELF


ELF也是将字节序列赋值到内存空间中,然后调转到entry point(_start)开始运行.但是特别的是,它是分段授权,分段赋值的.

上面我们给出了定义:可执行文件描述状态机的初始状态,那么具体描述了什么东西呢:![Alt text](image-47.png)
**描述了具体哪一段要分配到虚拟内存的哪一个位置,并且各个段的执行权限是多少**

更加了解了execve的实现,对于file可执行程序,其实execve首先按照elf文件的要求把对应的段赋值到虚拟内存的指定位置(利用elf的设计者设计的loder可以得到elf信息),随后创建了一个stack,把argc,*argv,envp都都传入,然后返回一个栈顶指针. 然后跳转到_start执行.