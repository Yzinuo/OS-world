# 如何查看进程的地址空间？
- 在LINUX中 everything is file。  我们可以在proc/进程号/maps 看进程的地址空间。
- 利用工具：pmap 进程号
- 


## 如何理解地址空间
一方面  地址空间是一段连续的平坦的0-2^64-1的地址空间。 我们可以把任何64位的整数转换成指针去访问内存。
一方面，地址空间被分为很多个段，每一个段都有自己对应的操作权限。

# mmap 系统调用
mmap 在状态机中增加/删除/修改一个可访问的内存

mprotect 系统调用，可以修改内存映射权限。

mmap可以瞬间分配一个巨大的内存，甚至等大于计算机的内存，这是为什么？

# 金手指
## gdb 为什么能看到别的进程的内心世界？
首先，每一个进程应该是封闭的，类似于人，每个人都看不透其他人在想什么。 那么为什么gdb可以看到呢？

是因为gdb有一个特别的系统调用可以把目标进程的空间搬到gdb进程里。
## 金手指：直接物理劫持内存
金手指是怎么做到入侵别人的进程空间的呢？
![Alt text](image-36.png)

当时游戏机的结构如上，当cpu要读rom上的代码的时候执行游戏的时候，我们可以在改变这个传输数据的电线，劫持这个传输的数据并修改。 然后研发出了直接设计了一个firmware，想启动游戏就的先启动作弊器金手指，然后金手指会调用卡带启动游戏。 这个金手指会修改特定指令的值达到作弊的效果。


# 金山游侠
当我们知道游戏越做越大，变量越来越多，很难一眼找到我们作弊需要改变的变量。 那么我们需要入侵到这个进程空间，在我们改动目标变量（通过游戏）前后跟着改变的变量的地址。
## mem文件
maps 文件:
- maps文件提供了进程的虚拟内存区域（VMA）的映射信息。
- 它显示了每个内存段的地址范围、权限、偏移量、设备信息和文件路径。
- 通过maps文件，可以了解进程的内存布局，包括代码段、数据段、堆、栈等。

 mem 文件:
- mem文件代表了进程的物理内存内容。
- 它是一个字符设备文件，允许直接访问进程的物理内存空间。
- 通过mem文件，可以读取或修改进程的内存内容，但这通常需要特定的权限和知识。

## 金山游侠的实现

# 变速齿轮
首先计算指令无法感知时间按，syscall是唯一的感知时间的方法。
- gettimefolay
- sleep
- alarm

只要把这些时间感知的代码改为我们的代码就能实现程序的变速。

## 具体实现：
我们在使用gdb的时候，给gettimefolay函数大一个断点。当断点执行到进入函数内部的时候，强行用gdb.execute来执行汇编代码（我们自己的函数），然后强行return。

就可以实现跳过系统调用直接用我们自己的代码
![Alt text](image-37.png)

这个就叫HOOK机制。把目标函数的第一条命令变成跳转到我自己写的函数执行，执行我自己的逻辑，目标函数不执行它被钩子钩住了。

这个就叫HOOK机制。把目标函数的第一条命令变成跳转到我自己写的函数执行，执行我自己的逻辑，目标函数不执行它被钩子钩住了。


PATCH机制 用来去除或更新目标代码。常用来热补丁。不停机更新。

差异记录:
补丁记录了两个文件或代码版本之间的差异，这些差异可以是添加、修改或删除的内容。
版本更新:
通过应用补丁，可以将一个版本的更改应用到另一个版本，这对于修复错误、添加新功能或改进现有功能非常有用。