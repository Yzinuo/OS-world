# 概念

写入时复制（英语：Copy-on-write，简称COW）是一种计算机 [程序设计]领域的优化策略。其核心思想是，**如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是 [透明]的。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy) 被创建，因此多个调用者只是读取操作时可以共享同一份资源。**

---

# LINUX下的COW
## fork函数

fork用于创建子进程(等同于当前进程的副本)。
- 新的进程要通过老的进程复制自身得到，这就是fork！
- Linux的进程都通过init进程或init的子进程fork(vfork)出来的。
- 拷贝完的子进程 ， 它和父进程的堆栈是独立的。


**使用fork()函数后，它会立即从当前进程创建一个子进程。这个子进程是父进程的副本，除了PID和返回值等少数差异外，几乎所有的状态都是相同的。创建子进程之后，父进程和子进程都会继续执行fork()之后的代码。这就意味着，如果fork()后面有代码，那么这些代码会在两个进程中分别执行一次。父进程和子进程的执行路径会根据fork()的返回值来区分，父进程中fork()返回子进程的PID，而在子进程中fork()返回0。因此，通过检查fork()的返回值，程序可以知道它是在父进程中运行还是在子进程中运行，并相应地执行不同的代码块。**

## exce函数
一个进程想要执行另一个程序。既然创建新进程的唯一方法为调用fork，该进程于是首先调用fork创建一个自身的拷贝，然后其中一个拷贝（通常为子进程）调用exec把自身替换成新的程序。这是诸如shell之类程序的典型用法。

- exec系列函数在执行时会直接替换掉当前进程的地址空间。

## 详解COW

我们已经知道，我们创建子进程时，**会拷贝所有数据到子进程中，但是当我们想要子进程执行自己的程序的时候，当我们使用exce函数的时候，我们拷贝的数据就都会被清空。** 因此，拷贝数据这个操作是多余的，浪费时间。

为了解决这个问题，COW出现了

- fork创建的子进程与父进程共享内存空间。也就是说，**如果子进程不对内存进行写入的花，父进程不会复制给子进程**

  
- 如果子进程修改了数据段或堆栈段，操作系统会为这些段分配新的物理空间，以便子进程和父进程的这些段不再共享。

- 另一方面，如果子进程调用了exec来执行一个不同的程序，那么子进程的代码段、数据段和堆栈段都会被新程序替换，因此需要分配新的物理空间，以便子进程有自己独立的地址空间，不再与父进程共享任何内容。这样做的原因是exec调用会加载一个全新的程序，这个程序有自己的代码和数据，与父进程完全不同。

### 技术实现

fork()之后，kernel把父进程中所有的内存页的权限都设为read-only，然后子进程的地址空间指向父进程。当父子进程都只读内存时，相安无事。当其中某个进程写内存时，CPU硬件检测到内存页是read-only的，于是触发页异常中断（page-fault），陷入kernel的一个中断例程。中断例程中，kernel就会把触发的异常的页复制一份，于是父子进程各自持有独立的一份。

### 优点和缺点
优点：

- COW技术可以减少分配和复制大量资源时带来的瞬间延迟。
- COW技术可以减少不必要的资源分配


缺点：
    如果fork之后父子进程都需要频繁进行写操作，那么会产生大量分页错误， 得不偿失。