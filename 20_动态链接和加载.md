# 动态链接的必要性：
当程序加载到内存中，使用动态链接就保证了内存中某个库只有一个副本，大大的节省了内存空间。
**在大型项目中动态链接库十分重要**因为它可以带来以下几个好处：

**模块化开发**：各个小组可以将自己的代码编译成动态链接库，这样每个小组只需要关注自己的模块，而不需要了解整个项目的所有细节。这有助于提高开发效率和代码的可维护性。

**代码复用**：动态链接库中的代码可以被多个程序共享，这样可以避免重复编写相同的代码，节省开发时间和资源。在软件工程中：**复制总是不可靠的**

**更新和维护**：如果某个模块需要更新或修复，只需要重新编译该模块的动态链接库，而不需要重新编译整个项目。这使得更新和维护变得更加容易和高效。

# 实现动态链接
![Alt text](image-48.png)

**动态链接的思想**
编译器首先为库生成位置无关代码（映射到内存中任何位置都无所谓），映射完成后库有了确定的地址，在这个地址空间中，每个函数就有了确定的地址。
在可执行文件会同时生成一个**table**，指向了位置无关库的每个函数的地址。因此调用函数前多一次**查表**就行了。
此时，就算多个进程需要目标库，内存中有一份就行了。

**无论是多少个进程共享一个动态链接库，内存中就是一个副本**


==CPU就是被操作系统PUA烂了，给内存带上了Vision pro==  CPU（用户段以为有连续的地址，其实是CPU的CP3进行转换了的地址，物理地质上不连续） 
![Alt text](image-49.png)

## 真正动手实现动态链接：
第一步，我们当链接的时候，扫描所有目标文件，找到外部依赖的函数，把他们记录在TABLE中。
第二步，查询这些函数的真正地址，替换表中的数值为真正地址。方可运行。（在加载中运行）

# GOT (Global Offset Table)
我们实现动态链接的过程中，**最重要的是查询表**。这个查询表起初记录在表中时，他们的地址我们因为未知，我们直接置零。当动态链接库加载到内存的时候，我们才能确定地址，并**把这个查询表的地址完善。**改成准确地址。  这个地址栏就是GOT，是查询表的表项而已。

GOT（Global Offset Table，全局偏移表）**是每个使用动态链接库的程序都有的一个数据结构。**它主要用于在动态链接过程中存储外部函数和变量的地址。

**PIE 是 Position Independent Executable** 的缩写，中文翻译为“位置无关可执行文件”。这是一种可执行文件格式，允许操作系统在加载程序时将其加载到内存中的任何位置，而不需要固定的基地址。**PIE 的主要目的是增强安全性**，通过使程序的内存布局随机化来防止某些类型的攻击，例如缓冲区溢出攻击。

# PLT

当编译动态链接程序编译器的难点：这个文件执行函数或使用编译单元外部变量时，怎么判断它是来自.o还是.so文件呢？
- 第一种办法：调用前先查表GOT  这种冗余的查表，性能上是不可接受的
- 第二种方法：查询到地址之后，每一个都直接跳转； 不可以，因为直接跳转使用立即数，只有32位，不足以包括整个虚拟空间，可能够不到.so
  
为了解决这个问题，发明了PLT（Procedure Linkage Table）
为了性能，我们选择直接跳转，但是直接跳转够不到.so，我们可以够到PLT。因此PLT包含了跳转到GOT找到目标函数的地址和执行函数的指令。

**我想跳64步，但是我只能跳32步，那么我就先跳32步，再跳一大步**

Linux二进制文件**默认需要动态链接**，除非在编译时使用了-static选项。

动态链接器首先检查每个依赖字符串，看是否包含斜杠（/），如果包含，则将其解释为路径名并加载该共享对象。
如果不包含斜杠，则按以下顺序搜索：

使用环境变量LD_LIBRARY_PATH指定的目录（除非在安全执行模式下）。


在默认路径/lib和/usr/lib中查找。